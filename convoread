#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''convoread - a tool for using convore.com via CLI'''

# Authors:
#
# * Andrey Vlasovskikh
# * Alexander Solovyov
# * Mikhail Krivushin
# * Timofei Perevezentsev
#
# License: MIT

from __future__ import unicode_literals, print_function

import sys
import os
import base64
import json
import ssl
import traceback
from contextlib import closing
from netrc import netrc

PYTHON = sys.version_info[0]
if PYTHON == 3:
    from http.client import HTTPSConnection, HTTPException
    from urllib.parse import urlencode
else:
    from httplib import HTTPSConnection, HTTPException
    from urllib import urlencode

try:
    import locale
    ENCODING = locale.getpreferredencoding()
    if not ENCODING or ENCODING == 'mac-roman' or 'ascii' in ENCODING.lower():
        ENCODING = 'UTF-8'
except locale.Error:
    ENCODING = 'UTF-8'

CONFIG = {
    'HOSTNAME': 'convore.com',
    'DEBUG': False,
    'NETWORK_ENCODING': 'UTF-8',
    'LIVE_URL': '/api/live.json',
    'HTTP_TIMEOUT': 20,
    }

stdout = None
stderr = None

# Docs:
#
# * <https://convore.com/api/>

# TODO:
#
# * First of all, implement an endless stream of messages to stdout

def debug(msg, exc=False):
    if CONFIG['DEBUG']:
        print('debug: {0}'.format(msg).encode(ENCODING),
              file=stderr)
        if exc:
            traceback.print_exc()

def livestream(conn, login, password):
    '''Return an iterable over live events (currently: messages).

    HTTPConnection -> Iterable(object)
    '''
    headers = dict([authheader(login, password)])
    cursor = 'null'
    while True:
        url = '{path}?{params}'.format(
                  path=CONFIG['LIVE_URL'],
                  params=urlencode({'cursor': cursor}))
        conn.request('GET', url, headers=headers)
        try:
            r = conn.getresponse()
        except (HTTPException, ssl.SSLError):
            debug('sending next request...', exc=True)
            continue
        data = r.read().decode(CONFIG['NETWORK_ENCODING'])
        event = json.loads(data)

        messages = event.get('messages', [])
        if messages:
            cursor = messages[-1].get('_id', 'null')
        for m in messages:
            yield m


def display(message, fd):
    debug(str(message))

    kind = message['kind']
    if kind == 'message':
        s = '@{user}: {message}'.format(
            user=message['user']['username'],
            message=message['message'])
    elif kind in ('login', 'logout', 'mention'):
        s = None
    else:
        s = kind

    if s is not None:
        print(s.encode(ENCODING), file=fd)


def authheader(login, password):
    s = '%s:%s' % (login, password)
    value = base64.b64encode(s.encode(CONFIG['NETWORK_ENCODING']))
    return b'Authorization', b'Basic ' + value


def config():
    '''Read config for username and password'''
    rc = netrc()
    login, account, password = rc.authenticators(CONFIG['HOSTNAME'])
    return login, password


def main():
    global stdout, stderr
    stdout = os.fdopen(sys.stdout.fileno(), 'wb')
    stderr = os.fdopen(sys.stderr.fileno(), 'wb')
    with closing(HTTPSConnection(CONFIG['HOSTNAME'],
                                 timeout=CONFIG['HTTP_TIMEOUT'])) as conn:
        login, password = config()
        for msg in livestream(conn, login, password):
            try:
                display(msg, stdout)
            except KeyError:
                debug(str(msg))


if __name__ == '__main__':
    if '--debug' in sys.argv:
        CONFIG['DEBUG'] = True
    try:
        main()
    except KeyboardInterrupt:
        pass
